CCS PCM C Compiler, Version 5.007, 61971               03-Oca-24 23:14

               Filename:   C:\Users\ASUS\Desktop\micro_proje\micro_proje.lst

               ROM used:   1615 words (20%)
                           Largest free fragment is 2048
               RAM used:   36 (10%) at main() level
                           55 (15%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  03
0001:  MOVWF  0A
0002:  GOTO   355
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  BTFSS  0B.4
0018:  GOTO   01B
0019:  BTFSC  0B.1
001A:  GOTO   032
001B:  MOVLW  8C
001C:  MOVWF  04
001D:  BTFSS  00.1
001E:  GOTO   021
001F:  BTFSC  0C.1
0020:  GOTO   035
0021:  MOVF   22,W
0022:  MOVWF  04
0023:  MOVF   23,W
0024:  MOVWF  77
0025:  MOVF   24,W
0026:  MOVWF  78
0027:  MOVF   25,W
0028:  MOVWF  79
0029:  MOVF   26,W
002A:  MOVWF  7A
002B:  MOVF   20,W
002C:  MOVWF  0A
002D:  SWAPF  21,W
002E:  MOVWF  03
002F:  SWAPF  7F,F
0030:  SWAPF  7F,W
0031:  RETFIE
0032:  BCF    0A.3
0033:  BCF    0A.4
0034:  GOTO   040
0035:  BCF    0A.3
0036:  BCF    0A.4
0037:  GOTO   09D
.................... #include <16F877a.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
0038:  BCF    0A.0
0039:  BCF    0A.1
003A:  BCF    0A.2
003B:  ADDWF  02,F
003C:  RETLW  28
003D:  RETLW  0C
003E:  RETLW  01
003F:  RETLW  06
*
00BF:  DATA 8C,27
00C0:  DATA D4,27
00C1:  DATA CE,27
00C2:  DATA 4D,10
00C3:  DATA CD,27
00C4:  DATA C4,22
00C5:  DATA 00,00
00C6:  RETLW  53
00C7:  RETLW  4F
00C8:  RETLW  4C
00C9:  RETLW  3D
00CA:  RETLW  25
00CB:  RETLW  4C
00CC:  RETLW  75
00CD:  RETLW  20
00CE:  RETLW  53
00CF:  RETLW  41
00D0:  RETLW  47
00D1:  RETLW  3D
00D2:  RETLW  25
00D3:  RETLW  4C
00D4:  RETLW  75
00D5:  RETLW  20
00D6:  RETLW  A0
00D7:  RETLW  A0
00D8:  RETLW  00
00D9:  RETLW  20
00DA:  RETLW  20
00DB:  RETLW  45
00DC:  RETLW  52
00DD:  RETLW  52
00DE:  RETLW  4F
00DF:  RETLW  52
00E0:  RETLW  A0
00E1:  RETLW  A0
00E2:  RETLW  00
00E3:  RETLW  20
00E4:  RETLW  20
00E5:  RETLW  45
00E6:  RETLW  52
00E7:  RETLW  52
00E8:  RETLW  4F
00E9:  RETLW  52
00EA:  RETLW  A0
00EB:  RETLW  A0
00EC:  RETLW  00
00ED:  DATA 8C,26
00EE:  DATA 41,27
00EF:  DATA D5,22
00F0:  DATA 4C,10
00F1:  DATA CD,27
00F2:  DATA C4,2A
00F3:  DATA 00,01
00F4:  DATA D3,22
00F5:  DATA 52,2B
00F6:  DATA CF,29
00F7:  DATA D4,20
00F8:  DATA D4,22
00F9:  DATA A0,1E
00FA:  DATA A0,12
00FB:  DATA CC,3A
00FC:  DATA 00,00
*
01DB:  MOVF   0B,W
01DC:  MOVWF  3E
01DD:  BCF    0B.7
01DE:  BSF    03.5
01DF:  BSF    03.6
01E0:  BSF    0C.7
01E1:  BSF    0C.0
01E2:  NOP
01E3:  NOP
01E4:  BCF    03.5
01E5:  MOVF   0C,W
01E6:  ANDLW  7F
01E7:  BTFSC  03.2
01E8:  GOTO   222
01E9:  BCF    03.6
01EA:  MOVWF  3F
01EB:  BSF    03.6
01EC:  MOVF   0D,W
01ED:  BCF    03.6
01EE:  MOVWF  40
01EF:  BSF    03.6
01F0:  MOVF   0F,W
01F1:  BCF    03.6
01F2:  MOVWF  41
01F3:  MOVF   3F,W
01F4:  MOVWF  47
01F5:  CALL   1AF
01F6:  MOVF   40,W
01F7:  BSF    03.6
01F8:  MOVWF  0D
01F9:  BCF    03.6
01FA:  MOVF   41,W
01FB:  BSF    03.6
01FC:  MOVWF  0F
01FD:  BSF    03.5
01FE:  BSF    0C.7
01FF:  BSF    0C.0
0200:  NOP
0201:  NOP
0202:  BCF    03.5
0203:  RLF    0C,W
0204:  RLF    0E,W
0205:  ANDLW  7F
0206:  BTFSC  03.2
0207:  GOTO   222
0208:  BCF    03.6
0209:  MOVWF  3F
020A:  BSF    03.6
020B:  MOVF   0D,W
020C:  BCF    03.6
020D:  MOVWF  40
020E:  BSF    03.6
020F:  MOVF   0F,W
0210:  BCF    03.6
0211:  MOVWF  41
0212:  MOVF   3F,W
0213:  MOVWF  47
0214:  CALL   1AF
0215:  MOVF   40,W
0216:  BSF    03.6
0217:  MOVWF  0D
0218:  BCF    03.6
0219:  MOVF   41,W
021A:  BSF    03.6
021B:  MOVWF  0F
021C:  INCF   0D,F
021D:  BTFSC  03.2
021E:  INCF   0F,F
021F:  BCF    03.6
0220:  GOTO   1DE
0221:  BSF    03.6
0222:  BCF    03.6
0223:  BTFSC  3E.7
0224:  BSF    0B.7
0225:  RETURN
0226:  BSF    03.5
0227:  BSF    03.6
0228:  BSF    0C.7
0229:  BSF    0C.0
022A:  NOP
022B:  NOP
022C:  BCF    03.5
022D:  MOVF   0D,W
022E:  BCF    03.6
022F:  MOVWF  3F
0230:  BSF    03.6
0231:  MOVF   0F,W
0232:  BCF    03.6
0233:  MOVWF  40
0234:  BSF    03.6
0235:  MOVF   0C,W
0236:  BCF    03.6
0237:  MOVWF  47
0238:  CALL   1AF
0239:  MOVF   3F,W
023A:  BSF    03.6
023B:  MOVWF  0D
023C:  BCF    03.6
023D:  MOVF   40,W
023E:  BSF    03.6
023F:  MOVWF  0F
0240:  INCF   0D,F
0241:  BTFSC  03.2
0242:  INCF   0F,F
0243:  BCF    03.6
0244:  DECFSZ 3E,F
0245:  GOTO   226
0246:  RETURN
0247:  CLRF   46
0248:  MOVF   04,W
0249:  MOVWF  45
024A:  BCF    46.0
024B:  BTFSC  03.7
024C:  BSF    46.0
024D:  SWAPF  3F,W
024E:  IORLW  F0
024F:  MOVWF  41
0250:  ADDWF  41,F
0251:  ADDLW  E2
0252:  MOVWF  42
0253:  ADDLW  32
0254:  MOVWF  44
0255:  MOVF   3F,W
0256:  ANDLW  0F
0257:  ADDWF  42,F
0258:  ADDWF  42,F
0259:  ADDWF  44,F
025A:  ADDLW  E9
025B:  MOVWF  43
025C:  ADDWF  43,F
025D:  ADDWF  43,F
025E:  SWAPF  3E,W
025F:  ANDLW  0F
0260:  ADDWF  43,F
0261:  ADDWF  44,F
0262:  RLF    43,F
0263:  RLF    44,F
0264:  COMF   44,F
0265:  RLF    44,F
0266:  MOVF   3E,W
0267:  ANDLW  0F
0268:  ADDWF  44,F
0269:  RLF    41,F
026A:  MOVLW  07
026B:  MOVWF  40
026C:  MOVLW  0A
026D:  ADDWF  44,F
026E:  DECF   43,F
026F:  BTFSS  03.0
0270:  GOTO   26D
0271:  ADDWF  43,F
0272:  DECF   42,F
0273:  BTFSS  03.0
0274:  GOTO   271
0275:  ADDWF  42,F
0276:  DECF   41,F
0277:  BTFSS  03.0
0278:  GOTO   275
0279:  ADDWF  41,F
027A:  DECF   40,F
027B:  BTFSS  03.0
027C:  GOTO   279
027D:  MOVLW  40
027E:  MOVWF  04
027F:  BCF    03.7
0280:  MOVLW  07
0281:  ANDWF  45,W
0282:  BCF    45.6
0283:  ADDWF  04,F
0284:  MOVLW  44
0285:  SUBWF  04,W
0286:  BTFSC  03.2
0287:  BSF    45.6
0288:  MOVF   00,W
0289:  MOVWF  77
028A:  BTFSS  03.2
028B:  GOTO   294
028C:  BTFSC  45.6
028D:  GOTO   294
028E:  BTFSC  45.4
028F:  GOTO   2A6
0290:  BTFSC  45.3
0291:  GOTO   294
0292:  MOVLW  20
0293:  GOTO   297
0294:  BSF    45.3
0295:  BCF    45.4
0296:  MOVLW  30
0297:  ADDWF  77,F
0298:  CLRF   3F
0299:  MOVF   04,W
029A:  MOVWF  3E
029B:  BCF    3F.0
029C:  BTFSC  03.7
029D:  BSF    3F.0
029E:  MOVF   77,W
029F:  MOVWF  47
02A0:  CALL   1AF
02A1:  MOVF   3E,W
02A2:  MOVWF  04
02A3:  BCF    03.7
02A4:  BTFSC  3F.0
02A5:  BSF    03.7
02A6:  INCF   04,F
02A7:  BTFSS  45.6
02A8:  GOTO   284
02A9:  RETURN
02AA:  MOVF   3F,W
02AB:  XORWF  41,W
02AC:  ANDLW  80
02AD:  MOVWF  43
02AE:  BTFSS  3F.7
02AF:  GOTO   2B5
02B0:  COMF   3E,F
02B1:  COMF   3F,F
02B2:  INCF   3E,F
02B3:  BTFSC  03.2
02B4:  INCF   3F,F
02B5:  BTFSS  41.7
02B6:  GOTO   2BC
02B7:  COMF   40,F
02B8:  COMF   41,F
02B9:  INCF   40,F
02BA:  BTFSC  03.2
02BB:  INCF   41,F
02BC:  MOVLW  10
02BD:  MOVWF  42
02BE:  CLRF   77
02BF:  CLRF   7A
02C0:  RRF    3F,F
02C1:  RRF    3E,F
02C2:  BTFSS  03.0
02C3:  GOTO   2CA
02C4:  MOVF   40,W
02C5:  ADDWF  77,F
02C6:  BTFSC  03.0
02C7:  INCF   7A,F
02C8:  MOVF   41,W
02C9:  ADDWF  7A,F
02CA:  RRF    7A,F
02CB:  RRF    77,F
02CC:  RRF    79,F
02CD:  RRF    78,F
02CE:  DECFSZ 42,F
02CF:  GOTO   2C0
02D0:  BTFSS  43.7
02D1:  GOTO   2D7
02D2:  COMF   78,F
02D3:  COMF   79,F
02D4:  INCF   78,F
02D5:  BTFSC  03.2
02D6:  INCF   79,F
02D7:  BCF    0A.3
02D8:  BCF    0A.4
02D9:  GOTO   48C (RETURN)
02DA:  BSF    03.5
02DB:  BSF    03.6
02DC:  BSF    0C.7
02DD:  BSF    0C.0
02DE:  NOP
02DF:  NOP
02E0:  BCF    03.5
02E1:  MOVF   0C,F
02E2:  BTFSC  03.2
02E3:  GOTO   2FD
02E4:  MOVF   0D,W
02E5:  BCF    03.6
02E6:  MOVWF  3E
02E7:  BSF    03.6
02E8:  MOVF   0F,W
02E9:  BCF    03.6
02EA:  MOVWF  3F
02EB:  BSF    03.6
02EC:  MOVF   0C,W
02ED:  BCF    03.6
02EE:  MOVWF  47
02EF:  CALL   1AF
02F0:  MOVF   3E,W
02F1:  BSF    03.6
02F2:  MOVWF  0D
02F3:  BCF    03.6
02F4:  MOVF   3F,W
02F5:  BSF    03.6
02F6:  MOVWF  0F
02F7:  INCF   0D,F
02F8:  BTFSC  03.2
02F9:  INCF   0F,F
02FA:  BCF    03.6
02FB:  GOTO   2DA
02FC:  BSF    03.6
02FD:  BCF    03.6
02FE:  RETURN
02FF:  MOVF   0B,W
0300:  MOVWF  3F
0301:  BCF    0B.7
0302:  BSF    03.5
0303:  BSF    03.6
0304:  BSF    0C.7
0305:  BSF    0C.0
0306:  NOP
0307:  NOP
0308:  BTFSC  03.0
0309:  GOTO   331
030A:  BCF    03.5
030B:  MOVF   0C,W
030C:  ANDLW  7F
030D:  BCF    03.6
030E:  MOVWF  40
030F:  BSF    03.6
0310:  MOVF   0D,W
0311:  BCF    03.6
0312:  MOVWF  41
0313:  BSF    03.6
0314:  MOVF   0F,W
0315:  BCF    03.6
0316:  MOVWF  42
0317:  MOVF   40,W
0318:  MOVWF  47
0319:  CALL   1AF
031A:  MOVF   41,W
031B:  BSF    03.6
031C:  MOVWF  0D
031D:  BCF    03.6
031E:  MOVF   42,W
031F:  BSF    03.6
0320:  MOVWF  0F
0321:  BSF    03.5
0322:  BSF    0C.7
0323:  BSF    0C.0
0324:  NOP
0325:  NOP
0326:  BCF    03.5
0327:  BCF    03.6
0328:  DECFSZ 3E,F
0329:  GOTO   32B
032A:  GOTO   32E
032B:  BSF    03.5
032C:  BSF    03.6
032D:  GOTO   331
032E:  GOTO   350
032F:  BSF    03.5
0330:  BSF    03.6
0331:  BCF    03.5
0332:  RLF    0C,W
0333:  RLF    0E,W
0334:  ANDLW  7F
0335:  BCF    03.6
0336:  MOVWF  40
0337:  BSF    03.6
0338:  MOVF   0D,W
0339:  BCF    03.6
033A:  MOVWF  41
033B:  BSF    03.6
033C:  MOVF   0F,W
033D:  BCF    03.6
033E:  MOVWF  42
033F:  MOVF   40,W
0340:  MOVWF  47
0341:  CALL   1AF
0342:  MOVF   41,W
0343:  BSF    03.6
0344:  MOVWF  0D
0345:  BCF    03.6
0346:  MOVF   42,W
0347:  BSF    03.6
0348:  MOVWF  0F
0349:  INCF   0D,F
034A:  BTFSC  03.2
034B:  INCF   0F,F
034C:  BCF    03.0
034D:  BCF    03.6
034E:  DECFSZ 3E,F
034F:  GOTO   302
0350:  BTFSC  3F.7
0351:  BSF    0B.7
0352:  BCF    0A.3
0353:  BCF    0A.4
0354:  GOTO   5DB (RETURN)
....................  
.................... #list 
....................  
.................... #use delay(clock=20000000) 
*
00FD:  MOVLW  48
00FE:  MOVWF  04
00FF:  BCF    03.7
0100:  MOVF   00,W
0101:  BTFSC  03.2
0102:  GOTO   110
0103:  MOVLW  06
0104:  MOVWF  78
0105:  CLRF   77
0106:  DECFSZ 77,F
0107:  GOTO   106
0108:  DECFSZ 78,F
0109:  GOTO   105
010A:  MOVLW  7B
010B:  MOVWF  77
010C:  DECFSZ 77,F
010D:  GOTO   10C
010E:  DECFSZ 00,F
010F:  GOTO   103
0110:  RETURN
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
012E:  MOVLW  0F
012F:  BSF    03.5
0130:  ANDWF  08,W
0131:  IORLW  F0
0132:  MOVWF  08
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0133:  BCF    03.5
0134:  BSF    08.2
....................    delay_cycles(1); 
0135:  NOP
....................    lcd_output_enable(1); 
0136:  BSF    08.0
....................    delay_cycles(1); 
0137:  NOP
....................    high = lcd_read_nibble(); 
0138:  CALL   122
0139:  MOVF   78,W
013A:  MOVWF  4F
....................        
....................    lcd_output_enable(0); 
013B:  BCF    08.0
....................    delay_cycles(1); 
013C:  NOP
....................    lcd_output_enable(1); 
013D:  BSF    08.0
....................    delay_us(1); 
013E:  GOTO   13F
013F:  GOTO   140
0140:  NOP
....................    low = lcd_read_nibble(); 
0141:  CALL   122
0142:  MOVF   78,W
0143:  MOVWF  4E
....................        
....................    lcd_output_enable(0); 
0144:  BCF    08.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0145:  MOVLW  0F
0146:  BSF    03.5
0147:  ANDWF  08,W
0148:  MOVWF  08
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0149:  BCF    03.5
014A:  SWAPF  4F,W
014B:  MOVWF  77
014C:  MOVLW  F0
014D:  ANDWF  77,F
014E:  MOVF   77,W
014F:  IORWF  4E,W
0150:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
0122:  MOVF   08,W
0123:  MOVWF  77
0124:  SWAPF  08,W
0125:  ANDLW  0F
0126:  MOVWF  78
....................   #endif 
0127:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
0111:  SWAPF  4F,W
0112:  ANDLW  F0
0113:  MOVWF  77
0114:  MOVLW  0F
0115:  ANDWF  08,W
0116:  IORWF  77,W
0117:  MOVWF  08
....................   #endif 
....................        
....................    delay_cycles(1); 
0118:  NOP
....................    lcd_output_enable(1); 
0119:  BSF    08.0
....................    delay_us(2); 
011A:  MOVLW  02
011B:  MOVWF  77
011C:  DECFSZ 77,F
011D:  GOTO   11C
011E:  GOTO   11F
011F:  NOP
....................    lcd_output_enable(0); 
0120:  BCF    08.0
0121:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
0128:  BSF    03.5
0129:  BCF    08.0
....................    lcd_rs_tris(); 
012A:  BCF    08.1
....................    lcd_rw_tris(); 
012B:  BCF    08.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
012C:  BCF    03.5
012D:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
0151:  MOVF   78,W
0152:  MOVWF  4E
0153:  BTFSC  4E.7
0154:  GOTO   12E
....................    lcd_output_rs(address); 
0155:  BTFSS  4C.0
0156:  BCF    08.1
0157:  BTFSC  4C.0
0158:  BSF    08.1
....................    delay_cycles(1); 
0159:  NOP
....................    lcd_output_rw(0); 
015A:  BCF    08.2
....................    delay_cycles(1); 
015B:  NOP
....................    lcd_output_enable(0); 
015C:  BCF    08.0
....................    lcd_send_nibble(n >> 4); 
015D:  SWAPF  4D,W
015E:  MOVWF  4E
015F:  MOVLW  0F
0160:  ANDWF  4E,F
0161:  MOVF   4E,W
0162:  MOVWF  4F
0163:  CALL   111
....................    lcd_send_nibble(n & 0xf); 
0164:  MOVF   4D,W
0165:  ANDLW  0F
0166:  MOVWF  4E
0167:  MOVWF  4F
0168:  CALL   111
0169:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
016A:  MOVLW  0F
016B:  BSF    03.5
016C:  ANDWF  08,W
016D:  MOVWF  08
....................   #endif 
....................    lcd_enable_tris(); 
016E:  BCF    08.0
....................    lcd_rs_tris(); 
016F:  BCF    08.1
....................    lcd_rw_tris(); 
0170:  BCF    08.2
....................  #endif 
....................  
....................    lcd_output_rs(0); 
0171:  BCF    03.5
0172:  BCF    08.1
....................    lcd_output_rw(0); 
0173:  BCF    08.2
....................    lcd_output_enable(0); 
0174:  BCF    08.0
....................      
....................    delay_ms(15); 
0175:  MOVLW  0F
0176:  MOVWF  48
0177:  CALL   0FD
....................    for(i=1;i<=3;++i) 
0178:  MOVLW  01
0179:  MOVWF  3E
017A:  MOVF   3E,W
017B:  SUBLW  03
017C:  BTFSS  03.0
017D:  GOTO   186
....................    { 
....................        lcd_send_nibble(3); 
017E:  MOVLW  03
017F:  MOVWF  4F
0180:  CALL   111
....................        delay_ms(5); 
0181:  MOVLW  05
0182:  MOVWF  48
0183:  CALL   0FD
0184:  INCF   3E,F
0185:  GOTO   17A
....................    } 
....................     
....................    lcd_send_nibble(2); 
0186:  MOVLW  02
0187:  MOVWF  4F
0188:  CALL   111
....................    delay_ms(5); 
0189:  MOVLW  05
018A:  MOVWF  48
018B:  CALL   0FD
....................    for(i=0;i<=3;++i) 
018C:  CLRF   3E
018D:  MOVF   3E,W
018E:  SUBLW  03
018F:  BTFSS  03.0
0190:  GOTO   19A
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0191:  MOVF   3E,W
0192:  CALL   038
0193:  MOVWF  3F
0194:  CLRF   4C
0195:  MOVF   3F,W
0196:  MOVWF  4D
0197:  CALL   128
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0198:  INCF   3E,F
0199:  GOTO   18D
019A:  BCF    0A.3
019B:  BCF    0A.4
019C:  GOTO   3D1 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
019D:  DECFSZ 49,W
019E:  GOTO   1A0
019F:  GOTO   1A3
....................       address=LCD_LINE_TWO; 
01A0:  MOVLW  40
01A1:  MOVWF  4A
01A2:  GOTO   1A4
....................    else 
....................       address=0; 
01A3:  CLRF   4A
....................       
....................    address+=x-1; 
01A4:  MOVLW  01
01A5:  SUBWF  48,W
01A6:  ADDWF  4A,F
....................    lcd_send_byte(0,0x80|address); 
01A7:  MOVF   4A,W
01A8:  IORLW  80
01A9:  MOVWF  4B
01AA:  CLRF   4C
01AB:  MOVF   4B,W
01AC:  MOVWF  4D
01AD:  CALL   128
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01AE:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
01AF:  MOVF   47,W
01B0:  XORLW  07
01B1:  BTFSC  03.2
01B2:  GOTO   1BD
01B3:  XORLW  0B
01B4:  BTFSC  03.2
01B5:  GOTO   1C2
01B6:  XORLW  06
01B7:  BTFSC  03.2
01B8:  GOTO   1CA
01B9:  XORLW  02
01BA:  BTFSC  03.2
01BB:  GOTO   1D0
01BC:  GOTO   1D5
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
01BD:  MOVLW  01
01BE:  MOVWF  48
01BF:  MOVWF  49
01C0:  CALL   19D
01C1:  GOTO   1DA
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
01C2:  CLRF   4C
01C3:  MOVLW  01
01C4:  MOVWF  4D
01C5:  CALL   128
....................                      delay_ms(2); 
01C6:  MOVLW  02
01C7:  MOVWF  48
01C8:  CALL   0FD
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
01C9:  GOTO   1DA
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
01CA:  MOVLW  01
01CB:  MOVWF  48
01CC:  MOVLW  02
01CD:  MOVWF  49
01CE:  CALL   19D
01CF:  GOTO   1DA
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
01D0:  CLRF   4C
01D1:  MOVLW  10
01D2:  MOVWF  4D
01D3:  CALL   128
01D4:  GOTO   1DA
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
01D5:  MOVLW  01
01D6:  MOVWF  4C
01D7:  MOVF   47,W
01D8:  MOVWF  4D
01D9:  CALL   128
....................      #endif 
....................    } 
01DA:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #fuses HS,WDT 
....................  
.................... #priority INT_EXT,INT_RB ,INT_TIMER2 
.................... #DEFINE SLEEP_MODE_ON 0x02 
.................... #DEFINE OTONOM_MODE_ON 0x01 
.................... #DEFINE OTONOM_MODE_OFF 0x00 
.................... int8 MODE_STATE; 
.................... /*debouncedelay deðiþkeni koymamýzýn sebebi program içerisinde yaklaþýk 10ms sayýp kesmeye gidildiðinde bir önceki kesmeden 10ms süre geçti mi bunu kontrol etmektir. 
.................... kesme içerisinde delay kullanmak doðru deðildir bu programýn diðer kesmelere girerken problem çýkarmasýna neden olabiliyor. bu yöntem sayesinde butonlardaki debounce 
.................... filtreleme olayýný yazýlýmla filtrelemiþ oluyoruz bunun diðer bir yöntemi ise donanýmsal olarak butonun baðlý olduðu devrede rc devresi eklemektir. 
.................... */ 
.................... unsigned long long debouncedelay_loopauto=2;  
.................... unsigned long long debouncedelay_loopmanuel=0; 
....................  
.................... #BYTE STATUS = 0x03 
.................... #bit RP0 =STATUS.5 
.................... #bit RP1 =STATUS.6 
....................  
.................... /*GPIO PORT CONTROL REGISTERS*/ 
.................... #BYTE TRISB = 0x86 
.................... #BYTE TRISD = 0x88 
.................... #BYTE PORTB = 0x06 
.................... #bit MODE_SELECT_PIN = PORTB.0 
.................... #bit SERVOPIN =PORTB.1 
.................... #bit RIGHT_MOVE =PORTB.2 
.................... #bit LEFT_MOVE =PORTB.3 
.................... #BYTE PORTD = 0x08 
....................  
.................... /*GENERAL INTERRUPTS CONTROL*/ 
.................... #BYTE INTCON =0x0b 
.................... #bit GIE = INTCON.7 
.................... #bit PEIE = INTCON.6 
....................  
.................... /*TIMER2 INTERRUPT CONTROL REGISTERS*/ 
.................... #BYTE PIE1 = 0x8c  
.................... #bit TMR2IE=PIE1.1 
.................... #BYTE PIR = 0x0c 
.................... #bit  TMR2IF=PIR.1 
....................  
.................... /*EXTERNAL INTERRUPT CONTROL REGISTERS*/ 
.................... #BYTE OPTION_REG =0x81 
.................... #bit INTEDG = OPTION_REG.6 //external interrupt edge select bit 
.................... #bit INTE =INTCON.4 //external interrupt enable/disable bit 
.................... #bit INTF =INTCON.1 //external interrupt flag  
....................  
.................... /*TIMER2 REGISTERS*/ 
.................... #BYTE T2CON = 0x12 
.................... #BYTE TMR2 = 0x11 
.................... #BYTE PR2 = 0x92 
....................  
.................... /*SERVO CONTROL VARIABLES*/ 
.................... const unsigned long mindegree=100; 
.................... const unsigned long maxdegree=500; 
.................... long duty=75; 
.................... long endtime =1000; 
.................... long j=0; 
.................... long servostate=300; 
....................  
.................... /* ADC REGISTERS */ 
.................... #byte ADRESL = 0x9E  
.................... #byte ADRESH = 0x1E  
.................... #byte ADCCON0 = 0x1F 
.................... #byte ADCCON1 = 0x9F  
.................... #bit CHANNEL=ADCCON0.3 
.................... #bit ADCCON0_GO_DONE = ADCCON0.2 //ADCCON0->GO/DONE 
.................... #bit ADCCON0_START = ADCCON0.0//ADCCON0->ADCON 
.................... /*ADC CONTROL VARIABLES*/ 
....................  long left_ldr; 
....................  long right_ldr; 
....................  signed long difference;  
....................   
.................... #INT_EXT 
.................... void MODE_SELECT(void) 
.................... { 
.................... INTF=0; 
*
0040:  BCF    0B.1
.................... if(MODE_SELECT_PIN==1) 
0041:  BTFSS  06.0
0042:  GOTO   099
....................    { 
....................       if((MODE_STATE==OTONOM_MODE_ON)&&(debouncedelay_loopauto>=3)) 
0043:  DECFSZ 27,W
0044:  GOTO   06D
0045:  MOVF   2B,F
0046:  BTFSS  03.2
0047:  GOTO   052
0048:  MOVF   2A,F
0049:  BTFSS  03.2
004A:  GOTO   052
004B:  MOVF   29,F
004C:  BTFSS  03.2
004D:  GOTO   052
004E:  MOVF   28,W
004F:  SUBLW  02
0050:  BTFSC  03.0
0051:  GOTO   06D
....................       { 
....................          MODE_STATE=OTONOM_MODE_OFF; 
0052:  CLRF   27
....................          write_eeprom(0,OTONOM_MODE_OFF); 
0053:  MOVF   0B,W
0054:  MOVWF  77
0055:  BCF    0B.7
0056:  BSF    03.6
0057:  CLRF   0D
0058:  CLRF   0C
0059:  BSF    03.5
005A:  BCF    0C.7
005B:  BSF    0C.2
005C:  MOVLW  55
005D:  MOVWF  0D
005E:  MOVLW  AA
005F:  MOVWF  0D
0060:  BSF    0C.1
0061:  BTFSC  0C.1
0062:  GOTO   061
0063:  BCF    0C.2
0064:  MOVF   77,W
0065:  BCF    03.5
0066:  BCF    03.6
0067:  IORWF  0B,F
....................          debouncedelay_loopauto=0; 
0068:  CLRF   2B
0069:  CLRF   2A
006A:  CLRF   29
006B:  CLRF   28
....................       } 
006C:  GOTO   099
....................       else if ((MODE_STATE==OTONOM_MODE_OFF)&&(debouncedelay_loopmanuel>=5)) 
006D:  MOVF   27,F
006E:  BTFSS  03.2
006F:  GOTO   099
0070:  MOVF   2F,F
0071:  BTFSS  03.2
0072:  GOTO   07D
0073:  MOVF   2E,F
0074:  BTFSS  03.2
0075:  GOTO   07D
0076:  MOVF   2D,F
0077:  BTFSS  03.2
0078:  GOTO   07D
0079:  MOVF   2C,W
007A:  SUBLW  04
007B:  BTFSC  03.0
007C:  GOTO   099
....................       { 
....................          debouncedelay_loopmanuel=0; 
007D:  CLRF   2F
007E:  CLRF   2E
007F:  CLRF   2D
0080:  CLRF   2C
....................          MODE_STATE=OTONOM_MODE_ON; 
0081:  MOVLW  01
0082:  MOVWF  27
....................          write_eeprom(0,OTONOM_MODE_ON); 
0083:  MOVF   0B,W
0084:  MOVWF  77
0085:  BCF    0B.7
0086:  BSF    03.6
0087:  CLRF   0D
0088:  MOVLW  01
0089:  MOVWF  0C
008A:  BSF    03.5
008B:  BCF    0C.7
008C:  BSF    0C.2
008D:  MOVLW  55
008E:  MOVWF  0D
008F:  MOVLW  AA
0090:  MOVWF  0D
0091:  BSF    0C.1
0092:  BTFSC  0C.1
0093:  GOTO   092
0094:  BCF    0C.2
0095:  MOVF   77,W
0096:  BCF    03.5
0097:  BCF    03.6
0098:  IORWF  0B,F
....................       } 
....................    } 
....................     
.................... } 
....................  
0099:  BCF    0B.1
009A:  BCF    0A.3
009B:  BCF    0A.4
009C:  GOTO   021
.................... #INT_TIMER2 
.................... void INT_TMR2(void) 
.................... { 
.................... TMR2IF=0; //reset interrupt flag 
009D:  BCF    0C.1
....................  
....................  
....................    if(j<endtime) 
009E:  MOVF   35,W
009F:  SUBWF  33,W
00A0:  BTFSS  03.0
00A1:  GOTO   0AC
00A2:  BTFSS  03.2
00A3:  GOTO   0A8
00A4:  MOVF   32,W
00A5:  SUBWF  34,W
00A6:  BTFSC  03.0
00A7:  GOTO   0AC
....................    { 
....................       j++; 
00A8:  INCF   34,F
00A9:  BTFSC  03.2
00AA:  INCF   35,F
....................    } 
00AB:  GOTO   0AE
....................    else  
....................    { 
....................       j=0; 
00AC:  CLRF   35
00AD:  CLRF   34
....................    } 
....................    if(j<=duty) 
00AE:  MOVF   35,W
00AF:  SUBWF  31,W
00B0:  BTFSS  03.0
00B1:  GOTO   0BA
00B2:  BTFSS  03.2
00B3:  GOTO   0B8
00B4:  MOVF   34,W
00B5:  SUBWF  30,W
00B6:  BTFSS  03.0
00B7:  GOTO   0BA
....................    { 
....................       SERVOPIN=1; 
00B8:  BSF    06.1
....................    } 
00B9:  GOTO   0BB
....................    else 
....................    { 
....................       SERVOPIN=0; 
00BA:  BCF    06.1
....................    } 
00BB:  BCF    0C.1
00BC:  BCF    0A.3
00BD:  BCF    0A.4
00BE:  GOTO   021
.................... } 
....................  
....................  
.................... void main() 
*
0355:  CLRF   2B
0356:  CLRF   2A
0357:  CLRF   29
0358:  MOVLW  02
0359:  MOVWF  28
035A:  CLRF   2F
035B:  CLRF   2E
035C:  CLRF   2D
035D:  CLRF   2C
035E:  CLRF   31
035F:  MOVLW  4B
0360:  MOVWF  30
0361:  MOVLW  03
0362:  MOVWF  33
0363:  MOVLW  E8
0364:  MOVWF  32
0365:  CLRF   35
0366:  CLRF   34
0367:  MOVLW  01
0368:  MOVWF  37
0369:  MOVLW  2C
036A:  MOVWF  36
036B:  BSF    03.5
036C:  BSF    1F.0
036D:  BSF    1F.1
036E:  BSF    1F.2
036F:  BCF    1F.3
0370:  MOVLW  07
0371:  MOVWF  1C
0372:  BCF    03.7
0373:  MOVLW  1F
0374:  ANDWF  03,F
.................... { 
.................... servostate=read_eeprom(1); 
0375:  MOVLW  01
0376:  BCF    03.5
0377:  BSF    03.6
0378:  MOVWF  0D
0379:  BSF    03.5
037A:  BCF    0C.7
037B:  BSF    0C.0
037C:  BCF    03.5
037D:  MOVF   0C,W
037E:  BCF    03.6
037F:  CLRF   37
0380:  MOVWF  36
.................... delay_ms(1); 
0381:  MOVLW  01
0382:  MOVWF  48
0383:  CALL   0FD
.................... servostate=servostate<<8; 
0384:  MOVF   36,W
0385:  MOVWF  37
0386:  CLRF   36
.................... servostate|=read_eeprom(2); 
0387:  MOVLW  02
0388:  BSF    03.6
0389:  MOVWF  0D
038A:  BSF    03.5
038B:  BCF    0C.7
038C:  BSF    0C.0
038D:  BCF    03.5
038E:  MOVF   0C,W
038F:  BCF    03.6
0390:  IORWF  36,F
.................... delay_ms(1); 
0391:  MOVLW  01
0392:  MOVWF  48
0393:  CALL   0FD
.................... duty=read_eeprom(3); 
0394:  MOVLW  03
0395:  BSF    03.6
0396:  MOVWF  0D
0397:  BSF    03.5
0398:  BCF    0C.7
0399:  BSF    0C.0
039A:  BCF    03.5
039B:  MOVF   0C,W
039C:  BCF    03.6
039D:  CLRF   31
039E:  MOVWF  30
....................  
.................... /*READ EEPROM MODE_STATE*/ 
.................... if(!((read_eeprom(0)==OTONOM_MODE_ON)||(read_eeprom(0)==OTONOM_MODE_OFF)))//eepromda baþlangýçta 0 veya 1 den farklý deðer verebiliyor debug yapýldýðýnda. 
039F:  BSF    03.6
03A0:  CLRF   0D
03A1:  BSF    03.5
03A2:  BCF    0C.7
03A3:  BSF    0C.0
03A4:  BCF    03.5
03A5:  MOVF   0C,W
03A6:  SUBLW  01
03A7:  BTFSC  03.2
03A8:  GOTO   3C8
03A9:  CLRF   0D
03AA:  BSF    03.5
03AB:  BCF    0C.7
03AC:  BSF    0C.0
03AD:  BCF    03.5
03AE:  MOVF   0C,W
03AF:  BTFSC  03.2
03B0:  GOTO   3C8
.................... { 
.................... write_eeprom(0,0); 
03B1:  BCF    03.6
03B2:  MOVF   0B,W
03B3:  MOVWF  77
03B4:  BCF    0B.7
03B5:  BSF    03.6
03B6:  CLRF   0D
03B7:  CLRF   0C
03B8:  BSF    03.5
03B9:  BCF    0C.7
03BA:  BSF    0C.2
03BB:  MOVLW  55
03BC:  MOVWF  0D
03BD:  MOVLW  AA
03BE:  MOVWF  0D
03BF:  BSF    0C.1
03C0:  BTFSC  0C.1
03C1:  GOTO   3C0
03C2:  BCF    0C.2
03C3:  MOVF   77,W
03C4:  BCF    03.5
03C5:  BCF    03.6
03C6:  IORWF  0B,F
03C7:  BSF    03.6
.................... } 
.................... MODE_STATE=read_eeprom(0); 
03C8:  CLRF   0D
03C9:  BSF    03.5
03CA:  BCF    0C.7
03CB:  BSF    0C.0
03CC:  BCF    03.5
03CD:  MOVF   0C,W
03CE:  BCF    03.6
03CF:  MOVWF  27
....................  
.................... lcd_init(); 
03D0:  GOTO   16A
.................... //ADC baþlatma konfigurasyonlarý 
.................... ADCCON0 = 0b01000100;  
03D1:  MOVLW  44
03D2:  MOVWF  1F
.................... ADCCON1 = 0b10000000;  
03D3:  MOVLW  80
03D4:  BSF    03.5
03D5:  MOVWF  1F
....................     
.................... RP0=1; //bir kez bank 1'e geçmek yeterli olacaktýr.**bank0->bank1** 
03D6:  BSF    03.5
.................... TRISD = 0x00; 
03D7:  CLRF   08
.................... TRISB = 0xFD; 
03D8:  MOVLW  FD
03D9:  MOVWF  06
.................... PORTB =0x00; 
03DA:  BCF    03.5
03DB:  CLRF   06
.................... PORTD=0; 
03DC:  CLRF   08
....................  
.................... INTCON = 0x00; //reset interrupt control register 
03DD:  CLRF   0B
.................... GIE = 1; //enable INTCON->GIE 
03DE:  BSF    0B.7
.................... PEIE = 1; //enable INTCON->PEIE 
03DF:  BSF    0B.6
....................  
.................... INTEDG=1; //rising edge 
03E0:  BSF    03.5
03E1:  BSF    01.6
.................... INTF=0; //external flag reset 
03E2:  BCF    03.5
03E3:  BCF    0B.1
.................... INTE=1; //external interrupt enable 
03E4:  BSF    0B.4
....................  
.................... /*RBIE=1;//exti interrupt enable 
.................... RBIF=0;//exti interrupt flag*/ 
....................  
.................... T2CON=0x04; 
03E5:  MOVLW  04
03E6:  MOVWF  12
.................... PIE1=0x00; //reset interrupts 
03E7:  BSF    03.5
03E8:  CLRF   0C
.................... TMR2IE=1; //timer2 interrupts on (PIE1->TMR2IE) 
03E9:  BSF    0C.1
.................... PR2 = 99; 
03EA:  MOVLW  63
03EB:  MOVWF  12
.................... TMR2=0; 
03EC:  BCF    03.5
03ED:  CLRF   11
.................... setup_wdt(WDT_2304MS); 
03EE:  MOVLW  0F
03EF:  MOVWF  77
03F0:  CLRF   01
03F1:  MOVLW  81
03F2:  MOVWF  04
03F3:  BCF    03.7
03F4:  MOVF   00,W
03F5:  ANDLW  F0
03F6:  IORLW  07
03F7:  MOVWF  00
03F8:  CLRWDT
03F9:  MOVF   00,W
03FA:  ANDLW  F7
03FB:  BTFSC  77.3
03FC:  ANDLW  F0
03FD:  IORWF  77,W
03FE:  MOVWF  00
.................... delay_ms(5); 
03FF:  MOVLW  05
0400:  MOVWF  48
0401:  CALL   0FD
.................... while(true) 
.................... { 
.................... while(MODE_STATE==OTONOM_MODE_ON) 
0402:  DECFSZ 27,W
0403:  GOTO   590
.................... { 
.................... restart_wdt(); 
0404:  CLRWDT
....................    /*READ LEFT LDR VALUE*/ 
....................    CHANNEL=0; 
0405:  BCF    1F.3
....................    delay_us(20); 
0406:  MOVLW  20
0407:  MOVWF  77
0408:  DECFSZ 77,F
0409:  GOTO   408
040A:  GOTO   40B
040B:  NOP
....................    ADCCON0_GO_DONE=1; 
040C:  BSF    1F.2
....................    ADCCON0_START=1; 
040D:  BSF    1F.0
....................    while(ADCCON0_GO_DONE==1);   
040E:  BTFSC  1F.2
040F:  GOTO   40E
....................    left_ldr = ADRESH; 
0410:  CLRF   39
0411:  MOVF   1E,W
0412:  MOVWF  38
....................    left_ldr = left_ldr<<8; 
0413:  MOVF   38,W
0414:  MOVWF  39
0415:  CLRF   38
....................    left_ldr |= ADRESL; 
0416:  BSF    03.5
0417:  MOVF   1E,W
0418:  BCF    03.5
0419:  IORWF  38,F
....................    delay_us(100); 
041A:  MOVLW  A6
041B:  MOVWF  77
041C:  DECFSZ 77,F
041D:  GOTO   41C
041E:  NOP
....................     
....................    /*READ RIGHT LDR VALUE*/       
....................    CHANNEL=1; 
041F:  BSF    1F.3
....................    delay_us(20); 
0420:  MOVLW  20
0421:  MOVWF  77
0422:  DECFSZ 77,F
0423:  GOTO   422
0424:  GOTO   425
0425:  NOP
....................    ADCCON0_GO_DONE=1; 
0426:  BSF    1F.2
....................    ADCCON0_START=1; 
0427:  BSF    1F.0
....................    while(ADCCON0_GO_DONE==1); 
0428:  BTFSC  1F.2
0429:  GOTO   428
....................    right_ldr = ADRESH; 
042A:  CLRF   3B
042B:  MOVF   1E,W
042C:  MOVWF  3A
....................    right_ldr = right_ldr<<8; 
042D:  MOVF   3A,W
042E:  MOVWF  3B
042F:  CLRF   3A
....................    right_ldr |=ADRESL;    
0430:  BSF    03.5
0431:  MOVF   1E,W
0432:  BCF    03.5
0433:  IORWF  3A,F
....................    delay_us(100); 
0434:  MOVLW  A6
0435:  MOVWF  77
0436:  DECFSZ 77,F
0437:  GOTO   436
0438:  NOP
....................    lcd_gotoxy(1,1); 
0439:  MOVLW  01
043A:  MOVWF  48
043B:  MOVWF  49
043C:  CALL   19D
....................    printf(lcd_putc,"\fOTONOM MODE"); 
043D:  MOVLW  BF
043E:  BSF    03.6
043F:  MOVWF  0D
0440:  MOVLW  00
0441:  MOVWF  0F
0442:  BCF    03.6
0443:  CALL   1DB
....................    lcd_gotoxy(1,2);  
0444:  MOVLW  01
0445:  MOVWF  48
0446:  MOVLW  02
0447:  MOVWF  49
0448:  CALL   19D
....................    printf(lcd_putc,"SOL=%Lu SAG=%Lu   ",left_ldr,right_ldr); 
0449:  MOVLW  C6
044A:  BSF    03.6
044B:  MOVWF  0D
044C:  MOVLW  00
044D:  MOVWF  0F
044E:  MOVLW  04
044F:  BCF    03.6
0450:  MOVWF  3E
0451:  CALL   226
0452:  MOVLW  10
0453:  MOVWF  04
0454:  MOVF   39,W
0455:  MOVWF  3F
0456:  MOVF   38,W
0457:  MOVWF  3E
0458:  CALL   247
0459:  MOVLW  CD
045A:  BSF    03.6
045B:  MOVWF  0D
045C:  MOVLW  00
045D:  MOVWF  0F
045E:  MOVLW  05
045F:  BCF    03.6
0460:  MOVWF  3E
0461:  CALL   226
0462:  MOVLW  10
0463:  MOVWF  04
0464:  MOVF   3B,W
0465:  MOVWF  3F
0466:  MOVF   3A,W
0467:  MOVWF  3E
0468:  CALL   247
0469:  MOVLW  20
046A:  MOVWF  47
046B:  CALL   1AF
046C:  MOVLW  A0
046D:  MOVWF  47
046E:  CALL   1AF
046F:  MOVLW  A0
0470:  MOVWF  47
0471:  CALL   1AF
....................    delay_ms(1); 
0472:  MOVLW  01
0473:  MOVWF  48
0474:  CALL   0FD
....................     
.................... /*AUTONOM SERVO DRIVE ALGORITHMA.*/    
....................    difference = left_ldr-right_ldr; //eðer fark negatifse ýþýk sað taraftan vuruyor anlamýna gelir.pozitife çevirip algoritmayý yazýyorum. 
0475:  MOVF   3A,W
0476:  SUBWF  38,W
0477:  MOVWF  77
0478:  MOVF   39,W
0479:  MOVWF  7A
047A:  MOVF   3B,W
047B:  BTFSS  03.0
047C:  INCFSZ 3B,W
047D:  SUBWF  7A,F
047E:  MOVF   77,W
047F:  MOVWF  3C
0480:  MOVF   7A,W
0481:  MOVWF  3D
....................    
....................    if(difference <0) 
0482:  BTFSS  3D.7
0483:  GOTO   4C0
....................    { 
....................       difference=difference*-1; 
0484:  MOVF   3D,W
0485:  MOVWF  3F
0486:  MOVF   3C,W
0487:  MOVWF  3E
0488:  MOVLW  FF
0489:  MOVWF  41
048A:  MOVWF  40
048B:  GOTO   2AA
048C:  MOVF   79,W
048D:  MOVWF  3D
048E:  MOVF   78,W
048F:  MOVWF  3C
....................       if (difference<200) 
0490:  BTFSC  3D.7
0491:  GOTO   498
0492:  MOVF   3D,F
0493:  BTFSS  03.2
0494:  GOTO   499
0495:  MOVF   3C,W
0496:  SUBLW  C7
0497:  BTFSC  03.0
....................       { 
....................       //tolerans aralýðý servostate deðiþkeni ldr sensörleri arasýndaki fark belli bir deðerden az ise deðiþmeyecektir. 
....................       } 
0498:  GOTO   4BF
....................       else if((difference>=200)&&(difference <=1024)) 
0499:  BTFSC  3D.7
049A:  GOTO   4B2
049B:  MOVF   3D,F
049C:  BTFSS  03.2
049D:  GOTO   4A2
049E:  MOVF   3C,W
049F:  SUBLW  C7
04A0:  BTFSC  03.0
04A1:  GOTO   4B2
04A2:  BTFSC  3D.7
04A3:  GOTO   4AE
04A4:  MOVF   3D,W
04A5:  SUBLW  04
04A6:  BTFSS  03.0
04A7:  GOTO   4B2
04A8:  BTFSS  03.2
04A9:  GOTO   4AE
04AA:  MOVF   3C,W
04AB:  SUBLW  00
04AC:  BTFSS  03.0
04AD:  GOTO   4B2
....................       { 
....................          servostate++; 
04AE:  INCF   36,F
04AF:  BTFSC  03.2
04B0:  INCF   37,F
....................       } 
04B1:  GOTO   4BF
....................       else 
....................       { 
....................          printf(lcd_putc,"\f"); 
04B2:  MOVLW  0C
04B3:  MOVWF  47
04B4:  CALL   1AF
....................          printf(lcd_putc,"  ERROR  "); 
04B5:  MOVLW  D9
04B6:  BSF    03.6
04B7:  MOVWF  0D
04B8:  MOVLW  00
04B9:  MOVWF  0F
04BA:  BCF    03.6
04BB:  CALL   2DA
....................          delay_ms(1); 
04BC:  MOVLW  01
04BD:  MOVWF  48
04BE:  CALL   0FD
....................       } 
....................    } 
04BF:  GOTO   4F2
....................    else if (difference >=0) 
04C0:  BTFSC  3D.7
04C1:  GOTO   4F2
....................    { 
....................       if(difference<200) 
04C2:  BTFSC  3D.7
04C3:  GOTO   4CA
04C4:  MOVF   3D,F
04C5:  BTFSS  03.2
04C6:  GOTO   4CB
04C7:  MOVF   3C,W
04C8:  SUBLW  C7
04C9:  BTFSC  03.0
....................       { 
....................        //tolerans aralýðý servostate deðiþkeni ldr sensörleri arasýndaki fark belli bir deðerden az ise deðiþmeyecektir. 
....................       } 
04CA:  GOTO   4F2
....................       else if((difference>=200)&&(difference <=1024)) 
04CB:  BTFSC  3D.7
04CC:  GOTO   4E5
04CD:  MOVF   3D,F
04CE:  BTFSS  03.2
04CF:  GOTO   4D4
04D0:  MOVF   3C,W
04D1:  SUBLW  C7
04D2:  BTFSC  03.0
04D3:  GOTO   4E5
04D4:  BTFSC  3D.7
04D5:  GOTO   4E0
04D6:  MOVF   3D,W
04D7:  SUBLW  04
04D8:  BTFSS  03.0
04D9:  GOTO   4E5
04DA:  BTFSS  03.2
04DB:  GOTO   4E0
04DC:  MOVF   3C,W
04DD:  SUBLW  00
04DE:  BTFSS  03.0
04DF:  GOTO   4E5
....................       { 
....................          servostate--; 
04E0:  MOVF   36,W
04E1:  BTFSC  03.2
04E2:  DECF   37,F
04E3:  DECF   36,F
....................       } 
04E4:  GOTO   4F2
....................       else 
....................       { 
....................          printf(lcd_putc,"\f"); 
04E5:  MOVLW  0C
04E6:  MOVWF  47
04E7:  CALL   1AF
....................          printf(lcd_putc,"  ERROR  "); 
04E8:  MOVLW  E3
04E9:  BSF    03.6
04EA:  MOVWF  0D
04EB:  MOVLW  00
04EC:  MOVWF  0F
04ED:  BCF    03.6
04EE:  CALL   2DA
....................          delay_ms(1); 
04EF:  MOVLW  01
04F0:  MOVWF  48
04F1:  CALL   0FD
....................       } 
....................     
....................    } 
....................    if(servostate>=maxdegree) 
04F2:  MOVF   37,W
04F3:  SUBLW  00
04F4:  BTFSC  03.0
04F5:  GOTO   50A
04F6:  XORLW  FF
04F7:  BTFSS  03.2
04F8:  GOTO   4FD
04F9:  MOVF   36,W
04FA:  SUBLW  F3
04FB:  BTFSC  03.0
04FC:  GOTO   50A
....................    { 
....................       servostate=maxdegree; 
04FD:  MOVLW  01
04FE:  MOVWF  37
04FF:  MOVLW  F4
0500:  MOVWF  36
....................       duty = servostate/4; 
0501:  RRF    37,W
0502:  MOVWF  31
0503:  RRF    36,W
0504:  MOVWF  30
0505:  RRF    31,F
0506:  RRF    30,F
0507:  MOVLW  3F
0508:  ANDWF  31,F
....................    } 
0509:  GOTO   525
....................    else if(servostate<=mindegree) 
050A:  MOVF   37,F
050B:  BTFSS  03.2
050C:  GOTO   51D
050D:  MOVF   36,W
050E:  SUBLW  64
050F:  BTFSS  03.0
0510:  GOTO   51D
....................    { 
....................       servostate=mindegree; 
0511:  CLRF   37
0512:  MOVLW  64
0513:  MOVWF  36
....................       duty = servostate/4; 
0514:  RRF    37,W
0515:  MOVWF  31
0516:  RRF    36,W
0517:  MOVWF  30
0518:  RRF    31,F
0519:  RRF    30,F
051A:  MOVLW  3F
051B:  ANDWF  31,F
....................    } 
051C:  GOTO   525
....................    else  
....................    { 
....................       duty=servostate/4; 
051D:  RRF    37,W
051E:  MOVWF  31
051F:  RRF    36,W
0520:  MOVWF  30
0521:  RRF    31,F
0522:  RRF    30,F
0523:  MOVLW  3F
0524:  ANDWF  31,F
....................    } 
....................    debouncedelay_loopauto++; 
0525:  MOVLW  01
0526:  ADDWF  28,F
0527:  BTFSC  03.0
0528:  INCF   29,F
0529:  BTFSC  03.2
052A:  INCF   2A,F
052B:  BTFSC  03.2
052C:  INCF   2B,F
....................    if(debouncedelay_loopauto==4294967296-1) //debounce filter sayacýný sýfýrlamýþ oluyoruz. 
052D:  INCFSZ 28,W
052E:  GOTO   53A
052F:  INCFSZ 29,W
0530:  GOTO   53A
0531:  INCFSZ 2A,W
0532:  GOTO   53A
0533:  INCFSZ 2B,W
0534:  GOTO   53A
....................    { 
....................       debouncedelay_loopauto=3; 
0535:  CLRF   2B
0536:  CLRF   2A
0537:  CLRF   29
0538:  MOVLW  03
0539:  MOVWF  28
....................    } 
....................    /*servo durumunu kayýt eder*/ 
....................    write_eeprom(1,make8(servostate,1)); 
053A:  MOVF   37,W
053B:  MOVWF  3E
053C:  MOVF   0B,W
053D:  MOVWF  77
053E:  BCF    0B.7
053F:  MOVLW  01
0540:  BSF    03.6
0541:  MOVWF  0D
0542:  BCF    03.6
0543:  MOVF   37,W
0544:  BSF    03.6
0545:  MOVWF  0C
0546:  BSF    03.5
0547:  BCF    0C.7
0548:  BSF    0C.2
0549:  MOVLW  55
054A:  MOVWF  0D
054B:  MOVLW  AA
054C:  MOVWF  0D
054D:  BSF    0C.1
054E:  BTFSC  0C.1
054F:  GOTO   54E
0550:  BCF    0C.2
0551:  MOVF   77,W
0552:  BCF    03.5
0553:  BCF    03.6
0554:  IORWF  0B,F
....................    delay_ms(2); 
0555:  MOVLW  02
0556:  MOVWF  48
0557:  CALL   0FD
....................    write_eeprom(2,make8(servostate,0)); 
0558:  MOVF   36,W
0559:  MOVWF  3E
055A:  MOVF   0B,W
055B:  MOVWF  77
055C:  BCF    0B.7
055D:  MOVLW  02
055E:  BSF    03.6
055F:  MOVWF  0D
0560:  BCF    03.6
0561:  MOVF   36,W
0562:  BSF    03.6
0563:  MOVWF  0C
0564:  BSF    03.5
0565:  BCF    0C.7
0566:  BSF    0C.2
0567:  MOVLW  55
0568:  MOVWF  0D
0569:  MOVLW  AA
056A:  MOVWF  0D
056B:  BSF    0C.1
056C:  BTFSC  0C.1
056D:  GOTO   56C
056E:  BCF    0C.2
056F:  MOVF   77,W
0570:  BCF    03.5
0571:  BCF    03.6
0572:  IORWF  0B,F
....................    delay_ms(2); 
0573:  MOVLW  02
0574:  MOVWF  48
0575:  CALL   0FD
....................    Write_eeprom(3,duty); 
0576:  MOVF   0B,W
0577:  MOVWF  77
0578:  BCF    0B.7
0579:  MOVLW  03
057A:  BSF    03.6
057B:  MOVWF  0D
057C:  BCF    03.6
057D:  MOVF   30,W
057E:  BSF    03.6
057F:  MOVWF  0C
0580:  BSF    03.5
0581:  BCF    0C.7
0582:  BSF    0C.2
0583:  MOVLW  55
0584:  MOVWF  0D
0585:  MOVLW  AA
0586:  MOVWF  0D
0587:  BSF    0C.1
0588:  BTFSC  0C.1
0589:  GOTO   588
058A:  BCF    0C.2
058B:  MOVF   77,W
058C:  BCF    03.5
058D:  BCF    03.6
058E:  IORWF  0B,F
058F:  GOTO   402
....................     
.................... } 
.................... while(MODE_STATE==OTONOM_MODE_OFF) 
0590:  MOVF   27,F
0591:  BTFSS  03.2
0592:  GOTO   64D
.................... { 
.................... restart_wdt(); 
0593:  CLRWDT
....................     
....................    if(RIGHT_MOVE) 
0594:  BTFSS  06.2
0595:  GOTO   5A9
....................    { 
....................       servostate++; 
0596:  INCF   36,F
0597:  BTFSC  03.2
0598:  INCF   37,F
....................       if(servostate>=maxdegree) 
0599:  MOVF   37,W
059A:  SUBLW  00
059B:  BTFSC  03.0
059C:  GOTO   5A8
059D:  XORLW  FF
059E:  BTFSS  03.2
059F:  GOTO   5A4
05A0:  MOVF   36,W
05A1:  SUBLW  F3
05A2:  BTFSC  03.0
05A3:  GOTO   5A8
....................       { 
....................          servostate=maxdegree; 
05A4:  MOVLW  01
05A5:  MOVWF  37
05A6:  MOVLW  F4
05A7:  MOVWF  36
....................       } 
....................       
....................    } 
05A8:  GOTO   5B9
....................    else if(LEFT_MOVE) 
05A9:  BTFSS  06.3
05AA:  GOTO   5B9
....................    { 
....................       servostate--; 
05AB:  MOVF   36,W
05AC:  BTFSC  03.2
05AD:  DECF   37,F
05AE:  DECF   36,F
....................       if(servostate<=mindegree) 
05AF:  MOVF   37,F
05B0:  BTFSS  03.2
05B1:  GOTO   5B9
05B2:  MOVF   36,W
05B3:  SUBLW  64
05B4:  BTFSS  03.0
05B5:  GOTO   5B9
....................       { 
....................          servostate=mindegree; 
05B6:  CLRF   37
05B7:  MOVLW  64
05B8:  MOVWF  36
....................       } 
....................       
....................    } 
....................    duty=servostate/4; 
05B9:  RRF    37,W
05BA:  MOVWF  31
05BB:  RRF    36,W
05BC:  MOVWF  30
05BD:  RRF    31,F
05BE:  RRF    30,F
05BF:  MOVLW  3F
05C0:  ANDWF  31,F
....................    lcd_gotoxy(1,1);  
05C1:  MOVLW  01
05C2:  MOVWF  48
05C3:  MOVWF  49
05C4:  CALL   19D
....................     printf(lcd_putc,"\fMANUEL MODU"); 
05C5:  MOVLW  ED
05C6:  BSF    03.6
05C7:  MOVWF  0D
05C8:  MOVLW  00
05C9:  MOVWF  0F
05CA:  BCF    03.6
05CB:  CALL   1DB
....................     lcd_gotoxy(1,2); 
05CC:  MOVLW  01
05CD:  MOVWF  48
05CE:  MOVLW  02
05CF:  MOVWF  49
05D0:  CALL   19D
....................    printf(lcd_putc,"SERVOSTATE = %Lu",servostate); 
05D1:  MOVLW  F4
05D2:  BSF    03.6
05D3:  MOVWF  0D
05D4:  MOVLW  00
05D5:  MOVWF  0F
05D6:  BCF    03.0
05D7:  MOVLW  0D
05D8:  BCF    03.6
05D9:  MOVWF  3E
05DA:  GOTO   2FF
05DB:  MOVLW  10
05DC:  MOVWF  04
05DD:  MOVF   37,W
05DE:  MOVWF  3F
05DF:  MOVF   36,W
05E0:  MOVWF  3E
05E1:  CALL   247
....................    debouncedelay_loopmanuel++; 
05E2:  MOVLW  01
05E3:  ADDWF  2C,F
05E4:  BTFSC  03.0
05E5:  INCF   2D,F
05E6:  BTFSC  03.2
05E7:  INCF   2E,F
05E8:  BTFSC  03.2
05E9:  INCF   2F,F
....................    if(debouncedelay_loopmanuel==4294967296-1) 
05EA:  INCFSZ 2C,W
05EB:  GOTO   5F7
05EC:  INCFSZ 2D,W
05ED:  GOTO   5F7
05EE:  INCFSZ 2E,W
05EF:  GOTO   5F7
05F0:  INCFSZ 2F,W
05F1:  GOTO   5F7
....................    { 
....................       debouncedelay_loopmanuel=2; 
05F2:  CLRF   2F
05F3:  CLRF   2E
05F4:  CLRF   2D
05F5:  MOVLW  02
05F6:  MOVWF  2C
....................    } 
....................    /*servo durumunu kayýt eder*/ 
....................    write_eeprom(1,make8(servostate,1)); 
05F7:  MOVF   37,W
05F8:  MOVWF  3E
05F9:  MOVF   0B,W
05FA:  MOVWF  77
05FB:  BCF    0B.7
05FC:  MOVLW  01
05FD:  BSF    03.6
05FE:  MOVWF  0D
05FF:  BCF    03.6
0600:  MOVF   37,W
0601:  BSF    03.6
0602:  MOVWF  0C
0603:  BSF    03.5
0604:  BCF    0C.7
0605:  BSF    0C.2
0606:  MOVLW  55
0607:  MOVWF  0D
0608:  MOVLW  AA
0609:  MOVWF  0D
060A:  BSF    0C.1
060B:  BTFSC  0C.1
060C:  GOTO   60B
060D:  BCF    0C.2
060E:  MOVF   77,W
060F:  BCF    03.5
0610:  BCF    03.6
0611:  IORWF  0B,F
....................    delay_ms(1); 
0612:  MOVLW  01
0613:  MOVWF  48
0614:  CALL   0FD
....................    write_eeprom(2,make8(servostate,0)); 
0615:  MOVF   36,W
0616:  MOVWF  3E
0617:  MOVF   0B,W
0618:  MOVWF  77
0619:  BCF    0B.7
061A:  MOVLW  02
061B:  BSF    03.6
061C:  MOVWF  0D
061D:  BCF    03.6
061E:  MOVF   36,W
061F:  BSF    03.6
0620:  MOVWF  0C
0621:  BSF    03.5
0622:  BCF    0C.7
0623:  BSF    0C.2
0624:  MOVLW  55
0625:  MOVWF  0D
0626:  MOVLW  AA
0627:  MOVWF  0D
0628:  BSF    0C.1
0629:  BTFSC  0C.1
062A:  GOTO   629
062B:  BCF    0C.2
062C:  MOVF   77,W
062D:  BCF    03.5
062E:  BCF    03.6
062F:  IORWF  0B,F
....................    delay_ms(1); 
0630:  MOVLW  01
0631:  MOVWF  48
0632:  CALL   0FD
....................    Write_eeprom(3,duty); 
0633:  MOVF   0B,W
0634:  MOVWF  77
0635:  BCF    0B.7
0636:  MOVLW  03
0637:  BSF    03.6
0638:  MOVWF  0D
0639:  BCF    03.6
063A:  MOVF   30,W
063B:  BSF    03.6
063C:  MOVWF  0C
063D:  BSF    03.5
063E:  BCF    0C.7
063F:  BSF    0C.2
0640:  MOVLW  55
0641:  MOVWF  0D
0642:  MOVLW  AA
0643:  MOVWF  0D
0644:  BSF    0C.1
0645:  BTFSC  0C.1
0646:  GOTO   645
0647:  BCF    0C.2
0648:  MOVF   77,W
0649:  BCF    03.5
064A:  BCF    03.6
064B:  IORWF  0B,F
064C:  GOTO   590
....................   } 
064D:  GOTO   402
....................  
.................... } 
.................... } 
064E:  SLEEP

Configuration Fuses:
   Word  1: 3F76   HS WDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
